<!DOCTYPE html>
<html lang="ro">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>FastTyper - Client</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Roboto+Mono:wght@400;500;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    
    <style>
        :root { --bg: #323437; --main: #e2b714; --sub: #646669; --text: #d1d0c5; --error: #ca4754; --error-extra: #7e2a33; }
        body { background: var(--bg); color: var(--text); font-family: 'Roboto Mono', monospace; overflow-x: hidden; }

        .screen { display: none; opacity: 0; transition: opacity 0.3s ease; }
        .screen.active { display: block; opacity: 1; }

        .btn { background: transparent; color: var(--sub); border: 2px solid transparent; padding: 0.75rem 2rem; border-radius: 0.5rem; transition: 0.2s; cursor: pointer; font-weight: 700; }
        .btn:hover { color: var(--text); border-color: var(--sub); }
        .btn-primary { color: var(--main); border-color: var(--main); }
        .btn-primary:hover { background: var(--main); color: var(--bg); }
        .grade-btn.selected { border-color: var(--main); color: var(--main); background: rgba(226, 183, 20, 0.1); }
        
        .input-ui { background: transparent; border: none; border-bottom: 2px solid var(--sub); color: var(--text); padding: 0.5rem; outline: none; font-size: 1.5rem; text-align: center; width: 100%; }
        .input-ui:focus { border-color: var(--main); }

        #typing-wrapper { background: #2c2e31; border-radius: 12px; padding: 1.5rem; position: relative; cursor: text; }
        #words-viewport { height: 120px; overflow: hidden; position: relative; mask-image: linear-gradient(to bottom, black 0%, black 80%, transparent 100%); }
        #scroll-wrapper { position: relative; top: 0; left: 0; width: 100%; transition: transform 0.2s ease-out; }
        #words-container { display: flex; flex-wrap: wrap; width: 100%; user-select: none; font-size: 1.7rem; line-height: 40px; }
        
        .word { margin-right: 0.6em; display: flex; border-bottom: 2px solid transparent; height: 40px; align-items: center; }
        .word.error-underline { border-bottom-color: var(--error); }
        .letter { position: relative; color: var(--sub); transition: color 0.1s; }
        .letter.correct { color: var(--text); }
        .letter.incorrect { color: var(--error); }
        .letter.extra { color: var(--error-extra); opacity: 0.7; }

        #caret { width: 2px; height: 1.8rem; background: var(--main); position: absolute; border-radius: 2px; transition: all 0.08s ease-out; z-index: 10; pointer-events: none; display: none; top: 0; left: 0; }
        #caret.active { display: block; }
        #caret.animate { animation: blink 1s infinite; }
        @keyframes blink { 0%, 100% { opacity: 1; } 50% { opacity: 0; } }

        .blur-overlay { position: absolute; inset: 0; background: rgba(0,0,0,0.4); backdrop-filter: blur(3px); display: flex; align-items: center; justify-content: center; z-index: 20; opacity: 0; pointer-events: none; transition: 0.2s; border-radius: 12px; }
        .blur-overlay.active { opacity: 1; pointer-events: auto; }
        
        .progress-bar-container { width: 100%; height: 4px; background: var(--sub); border-radius: 2px; overflow: hidden; }
        .progress-bar-fill { height: 100%; background: var(--main); transition: width 0.3s ease-out; border-radius: 2px; }
        
        @keyframes shake { 
        0%, 100% { transform: translateX(0); } 
        10%, 30%, 50%, 70%, 90% { transform: translateX(-10px); } 
        20%, 40%, 60%, 80% { transform: translateX(10px); } 
        }
        .animate-shake { animation: shake 0.6s; }

        .debug-info {
            position: fixed;
            bottom: 4px;
            left: 4px;
            font-size: 11px;
            color: #646669;
            font-family: 'Roboto Mono', monospace;
            opacity: 0.7;
        }
        .status-indicator { width: 10px; height: 10px; border-radius: 50%; }
        .status-green { background: #22c55e; box-shadow: 0 0 10px #22c55e; }
        .status-yellow { background: #eab308; box-shadow: 0 0 10px #eab308; }
        .status-red { background: #ef4444; box-shadow: 0 0 10px #ef4444; }
    </style>
</head>
<body class="min-h-screen flex flex-col">

    <header class="w-full p-6 flex justify-between items-center">
        <div class="flex items-center gap-3 cursor-pointer" onclick="location.reload()">
            <i class="fa-solid fa-keyboard text-3xl" style="color: var(--main)"></i>
            <div><h1 class="text-2xl font-bold">Fast<span style="color: var(--main)">Typer</span></h1></div>
        </div>
        <div class="flex items-center gap-4 text-sm" style="color: var(--sub)">
            <div class="flex items-center gap-2">
                <div id="status-dot" class="status-indicator status-red"></div>
                <span id="status-text">Connecting...</span>
            </div>
            <div class="flex items-center gap-2">
                <i class="fa-solid fa-user"></i>
                <span id="display-name">Guest</span>
            </div>
            <button onclick="changeName()" class="btn text-xs px-3 py-1" id="change-name-btn" style="display: none;">Schimba Numele</button>
        </div>
    </header>

    <main class="flex-1 flex items-center justify-center p-8">

<div id="connecting-screen" class="screen active text-center max-w-md w-full p-6">
    <div class="inline-block p-4 rounded-full mb-6" style="background: rgba(226, 183, 20, 0.1);">
        <i class="fa-solid fa-circle-notch fa-spin text-4xl" style="color: var(--main)"></i>
    </div>
    <h2 class="text-2xl font-bold mb-2">Se conectează...</h2>
    <p class="text-sm" style="color: var(--sub)">Se stabilește conexiunea cu serverul</p>
</div>

<div id="login-screen" class="screen text-center max-w-md w-full p-6">
    
    <div class="mb-10">
        <div class="inline-block p-4 rounded-full bg-opacity-10 mb-4" style="background: rgba(226, 183, 20, 0.1);">
            <i class="fa-solid fa-user-astronaut text-4xl" style="color: var(--main)"></i>
        </div>
        <h2 class="text-3xl font-bold">Bine ai venit!</h2>

    </div>

    <div class="mb-8 text-left">
        <label class="text-xs font-bold ml-1 uppercase tracking-wider mb-2 block" style="color: var(--sub)">Nume Utilizator</label>
        <div class="relative">
            <div class="absolute inset-y-0 left-0 pl-4 flex items-center pointer-events-none">
                <i class="fa-solid fa-user" style="color: var(--sub)"></i>
            </div>
            <input type="text" id="username-input" 
                class="w-full rounded-lg pl-12 pr-4 py-4 outline-none font-bold transition-all shadow-sm" 
                style="background: rgba(0,0,0,0.2); border: 2px solid var(--sub); color: var(--text);"
                placeholder="Introdu un Nume" maxlength="15" autocomplete="off"
                onfocus="this.style.borderColor = 'var(--main)'; this.style.background = 'rgba(0,0,0,0.4)';"
                onblur="this.style.borderColor = 'var(--sub)'; this.style.background = 'rgba(0,0,0,0.2)';">
        </div>
    </div>

    
    <div class="mb-10 text-left">
        <label class="text-xs font-bold ml-1 uppercase tracking-wider mb-2 block" style="color: var(--sub)">Selectează Clasa</label>
        <div class="grid grid-cols-3 gap-3" id="grade-buttons">
            <button onclick="selectGrade('1-4', this)" class="grade-btn btn w-full px-2 whitespace-nowrap" style="background: rgba(0,0,0,0.2)">1 - 4</button>
            <button onclick="selectGrade('5-9', this)" class="grade-btn btn w-full px-2 whitespace-nowrap" style="background: rgba(0,0,0,0.2)">5 - 9</button>
            <button onclick="selectGrade('10-12', this)" class="grade-btn btn w-full px-2 whitespace-nowrap" style="background: rgba(0,0,0,0.2)">10 - 12</button>
        </div>
    </div>

    <button onclick="joinGame()" class="btn btn-primary w-full py-4 text-lg shadow-lg flex items-center justify-center gap-3 hover:scale-[1.02] active:scale-[0.98] transition-transform">
        <span>Intră</span> 
        <i class="fa-solid fa-arrow-right"></i>
    </button>
</div>

        <div id="waiting-screen" class="screen text-center">
            <i class="fa-solid fa-hourglass-half text-6xl mb-4" style="color: var(--main)"></i>
            <h2 class="text-3xl font-bold mb-2">Asteptarea startului</h2>
            <div id="waiting-round-info" class="text-sm mt-1" style="color:var(--sub);"></div>
            <div class="bg-gray-800 p-4 rounded-lg inline-block min-w-[200px] mt-4">
                <p class="text-xs text-gray-500">Playeri Conectati</p>
                <p class="text-4xl font-bold text-white" id="waiting-count">0</p>
            </div>
        </div>

        <div id="game-screen" class="screen w-full max-w-4xl">
            <div class="flex justify-between items-center mb-4 text-xl" style="color: var(--main)">
                <div class="flex gap-8">
                    <div><span class="text-sm text-gray-500">Timp</span> <span id="timer" class="font-bold">60</span></div>
                    <div><span class="text-sm text-gray-500">CPM</span> <span id="live-wpm" class="font-bold">0</span></div>
                    <div><span class="text-sm text-gray-500">Acuratete</span> <span id="live-acc" class="font-bold">100%</span></div>
                </div>
                <div id="round-badge" class="text-sm font-bold px-3 py-1 rounded" style="background:rgba(226,183,20,0.15);color:var(--main);display:none;letter-spacing:1px;"></div>
            </div>

            <div id="typing-wrapper" onclick="focusInput()">
                <div id="words-viewport">
                    <div id="scroll-wrapper">
                        <div id="words-container"></div>
                        <div id="caret" class="animate"></div>
                    </div>
                </div>
                
                <input type="text" id="hidden-input" style="opacity: 0; position: absolute; pointer-events: none;" autocomplete="off">
                <div id="blur-overlay" class="blur-overlay"><div class="text-center text-white"><i class="fa-solid fa-arrow-pointer mb-2 text-2xl"></i><p>Click to Focus</p></div></div>
            </div>
        </div>

        <div id="results-screen" class="screen text-center max-w-2xl w-full">
            <div class="flex justify-between items-center mb-4">
                <h2 class="text-4xl font-bold">Rezultate</h2>
                <div id="res-round-info" class="text-sm font-bold px-3 py-1 rounded" style="background:rgba(226,183,20,0.15);color:var(--main);letter-spacing:1px;"></div>
            </div>
            <div class="grid grid-cols-2 gap-4 mb-8">
                <div class="bg-gray-800 p-6 rounded-xl"><div class="text-sm text-gray-500">CPM</div><div class="text-6xl font-bold text-yellow-400" id="res-wpm">0</div></div>
                <div class="bg-gray-800 p-6 rounded-xl"><div class="text-sm text-gray-500">Acuratete</div><div class="text-6xl font-bold text-yellow-400" id="res-acc">0%</div></div>
                <div class="bg-gray-800 p-4 rounded-xl"><div class="text-sm text-gray-500">Raw CPM</div><div class="text-2xl font-bold" id="res-raw">0</div></div>
                <div class="bg-gray-800 p-4 rounded-xl"><div class="text-sm text-gray-500">Consistenta</div><div class="text-2xl font-bold text-blue-400" id="res-cons">0%</div></div>
            </div>
            <div class="text-sm text-gray-500 mb-2">Se reincarca in <span id="reload-seconds" class="font-bold text-white">20</span>s</div>
            <div class="progress-bar-container">
                <div id="reload-bar" class="progress-bar-fill" style="width: 100%"></div>
            </div>
        </div>


        <div class="debug-info z-50 hover:opacity-100 transition-opacity">
        <div class="flex items-center gap-2 mb-1">
        <i class="fa-solid fa-network-wired text-xs"></i>
        <span id="sync-indicator"></span>
    </div>
    <div id="grade-indicator">Grade: <span id="grade-display">-</span></div>
</div>
        <a href="https://github.com/Dany0443" target="_blank" rel="noopener noreferrer" class="fixed bottom-4 right-4 z-50 flex items-center gap-2 opacity-50 hover:opacity-100 transition-opacity cursor-pointer text-gray-500 hover:text-[#e2b714]"> 
            <span class="text-xs font-mono hidden sm:inline">Created by Dany0443</span> 
            <i class="fa-brands fa-github text-xl"></i> 
        </a>

    </main>
    <div id="countdown-overlay" class="fixed inset-0 bg-gray-900 bg-opacity-95 hidden items-center justify-center z-50 flex"><div id="countdown-number" class="text-9xl font-bold text-yellow-500">3</div></div>

    <script>
        const WS_URL = "ws://localhost:5889";
        const LS_SESSION = "mt_session"; // shared key with spell.html
        
        let ws;
        let selectedGrade = null;
        let reconnectAttempts = 0;
        let maxReconnectDelay = 30000;
        let serverTimeOffset = 0;
        let lastSyncTime = 0;
        let stateVersion = 0;
        // True if user has valid saved session data (previous OR current session)
        let hasJoined = !!JSON.parse(localStorage.getItem(LS_SESSION) || 'null')?.userId;
        let currentRound = 0;
        let maxRounds = 3;
        
        let gameState = {
            active: false,
            words: [],
            history: [],
            wordIndex: 0,
            inputVal: "",
            startTime: 0,
            duration: 60,
            timer: null,
            reloadTimer: null, // Issue #3/#4: track so it can be cancelled
            stats: {
                correctChars: 0,
                totalChars: 0,
                errors: 0,
                wpmSnapshots: []
            }
        };

        const els = {
            screens: document.querySelectorAll('.screen'),
            input: document.getElementById('hidden-input'),
            scrollWrapper: document.getElementById('scroll-wrapper'),
            wordsContainer: document.getElementById('words-container'),
            caret: document.getElementById('caret'),
            overlay: document.getElementById('blur-overlay')
        };

        window.onload = () => {
            const user = JSON.parse(localStorage.getItem(LS_SESSION) || 'null');
            if (user && user.username) {
                document.getElementById('username-input').value = user.username;
                if (user.grade) selectGrade(user.grade, null);
                document.getElementById('grade-display').textContent = user.grade;
                document.getElementById('display-name').textContent = user.username;
            }
            // Start connecting — login screen shown only after connection succeeds
            connect();
        };

        function getServerTime() {
            return Date.now() + serverTimeOffset;
        }

        function updateRoundBadge() {
            if (!currentRound) return;
            const badge = document.getElementById('round-badge');
            const waitInfo = document.getElementById('waiting-round-info');
            const resInfo = document.getElementById('res-round-info');
            const txt = `RUNDA ${currentRound} / ${maxRounds}`;
            if (badge)   { badge.textContent = txt; badge.style.display = 'block'; }
            if (waitInfo) waitInfo.textContent = txt;
            if (resInfo)  resInfo.textContent  = txt;
        }

        function selectGrade(grade, btn) {
            selectedGrade = grade;
            document.querySelectorAll('.grade-btn').forEach(b => b.classList.remove('selected'));
            if (btn) {
                btn.classList.add('selected');
            } else {
                document.querySelectorAll('.grade-btn').forEach(b => { 
                    if (b.textContent.trim() === grade) b.classList.add('selected'); 
                });
            }
        }

        function switchScreen(id) {
            els.screens.forEach(s => s.classList.remove('active'));
            document.querySelectorAll('.screen').forEach(s => s.style.display = 'none');
            const t = document.getElementById(id);
            if (t) { 
                t.style.display = 'block'; 
                setTimeout(() => t.classList.add('active'), 50); 
            }
        }

        function connect() {
            ws = new WebSocket(WS_URL);
            
            ws.onopen = () => {
                reconnectAttempts = 0;
                document.getElementById('status-dot').className = 'status-indicator status-green';
                document.getElementById('status-text').textContent = 'Conectat';
                
                const user = JSON.parse(localStorage.getItem(LS_SESSION) || 'null');
                if (user && user.userId && user.username) {
                    // Has saved session — auto-rejoin silently
                    hasJoined = true;
                    ws.send(JSON.stringify({ 
                        type: 'RECONNECT', 
                        userId: user.userId,
                        username: user.username,
                        grade: user.grade || '5-9',
                        role: 'player'
                    }));
                    document.getElementById('display-name').textContent = user.username;
                    // JOIN_SUCCESS from server will switch to waiting-screen
                } else {
                    // Fresh user — show login form
                    switchScreen('login-screen');
                }
            };
            
            ws.onmessage = (e) => handleServerMessage(JSON.parse(e.data));
            
            ws.onclose = () => { 
                document.getElementById('status-dot').className = 'status-indicator status-red';
                
                const delay = Math.min(1000 * Math.pow(2, reconnectAttempts), maxReconnectDelay);
                reconnectAttempts++;
                
                document.getElementById('status-text').textContent = `Reconnecting in ${Math.floor(delay/1000)}s...`;
                
                // Show connecting screen only if we have no user data at all
                const user = JSON.parse(localStorage.getItem(LS_SESSION) || 'null');
                if (!user?.userId) {
                    switchScreen('connecting-screen');
                }
                
                setTimeout(connect, delay);
            };
            
            ws.onerror = () => {
                document.getElementById('status-dot').className = 'status-indicator status-red';
                document.getElementById('status-text').textContent = 'Connection Error';
            };
        }

        function handleServerMessage(data) {
            switch (data.type) {
                case 'TIME_SYNC':
                    if (data.requestSync) {
                        const t0 = Date.now();
                        ws.send(JSON.stringify({
                            type: 'TIME_SYNC_RESPONSE',
                            clientTime: Date.now(),
                            t0: t0
                        }));
                    }
                    break;

                case 'TIME_SYNC_RESULT':
                    const now = Date.now();
                    const rtt = now - data.t0; // Client Time - Client Time = Real RTT
                    const offset = data.serverTime - (now - (rtt / 2)); // Standard NTP Offset
                    
                    serverTimeOffset = offset;
                    lastSyncTime = now;
                    
                    // Send calculated stats back to server for logging (Step 2)
                    ws.send(JSON.stringify({
                        type: 'TIME_SYNC_RESPONSE',
                        step: 2,
                        rtt: rtt,
                        offset: offset
                    }));

                    const syncText = `Sync: ${offset > 0 ? '+' : ''}${Math.round(offset)}ms | Ping: ${rtt}ms`;
                    document.getElementById('sync-indicator').textContent = syncText;
                    
                    if (rtt > 200) {
                        document.getElementById('status-dot').className = 'status-indicator status-yellow';
                    } else {
                        document.getElementById('status-dot').className = 'status-indicator status-green';
                    }
    break;
                    
                case 'FULL_STATE_SYNC':
                    stateVersion = data.state?.version || stateVersion;
                    if (data.state?.currentRound) currentRound = data.state.currentRound;
                    if (data.state?.maxRounds)    maxRounds   = data.state.maxRounds;
                    if (data.state.phase === 'RACING' && !gameState.active) {
                        const elapsed = Math.floor((getServerTime() - data.state.startTime) / 1000);
                        if (elapsed < data.state.duration) {
                            switchScreen('game-screen');
                        }
                    }
                    break;
                
                case 'JOIN_SUCCESS':
                    if (data.currentRound) { currentRound = data.currentRound; maxRounds = data.maxRounds || maxRounds; }
                    switchScreen('waiting-screen');
                    document.getElementById('change-name-btn').style.display = 'block';
                    if (data.stateVersion) stateVersion = data.stateVersion;
                    updateRoundBadge();
                    break;
                    
                case 'UPDATE_LOBBY': 
                    document.getElementById('waiting-count').textContent = data.count;
                    if (data.stateVersion && data.stateVersion !== stateVersion) {
                        console.warn('State desync detected, requesting sync');
                        ws.send(JSON.stringify({ type: 'REQUEST_STATE_SYNC' }));
                    }
                    break;
                    
                case 'COUNTDOWN':
                    if (data.round) { currentRound = data.round; maxRounds = data.maxRounds || maxRounds; }
                    runCountdown(data.count);
                    break;
                    
                case 'START_GAME':
                    if (data.round) { currentRound = data.round; maxRounds = data.maxRounds || maxRounds; }
                    updateRoundBadge();
                    startGame(data.text, data.duration, data.startTime);
                    break;
                    
                case 'GAME_IN_PROGRESS':
                    if (data.round) { currentRound = data.round; maxRounds = data.maxRounds || maxRounds; }
                    updateRoundBadge();
                    const remaining = data.duration - data.elapsed;
                    if (remaining > 0) {
                        startGame(data.text, data.duration, data.startTime);
                    } else {
                        switchScreen('waiting-screen');
                    }
                    break;
                    
                case 'GAME_OVER':
                    if (data.round) currentRound = data.round;
                    // Issue #8: If game is still active, finalize it; cancel reload timer and go to waiting
                    if (gameState.active) endGame();
                    // Cancel auto-reload — multi-round flow: wait for next round
                    if (!data.isLastRound) {
                        if (gameState.reloadTimer) {
                            clearInterval(gameState.reloadTimer);
                            gameState.reloadTimer = null;
                        }
                        document.getElementById('reload-seconds').textContent = '—';
                        document.getElementById('reload-bar').style.width = '0%';
                    }
                    break;

                case 'MODE_CHANGED':
                    // Issue #10: Don't redirect mid-game — only redirect when idle
                    if (!gameState.active && data.mode === 'spell') window.location.href = 'spell.html';
                    break;

                case 'SYNC_STATE':
                    if (data.mode === 'spell') { window.location.href = 'spell.html'; return; }
                    if (data.currentRound) currentRound = data.currentRound;
                    if (data.maxRounds)   maxRounds   = data.maxRounds;
                    break;

                case 'SERIES_COMPLETE':
                case 'SERIES_OVER':
                    const st = document.getElementById('res-round-info');
                    if (st) st.textContent = 'Toate rundele complete!';
                    break;

                case 'FORCE_RESET':
                    // Issue #4: cancel any pending reload timer
                    if (gameState.reloadTimer) {
                        clearInterval(gameState.reloadTimer);
                        gameState.reloadTimer = null;
                    }
                    gameState.active = false;
                    currentRound = 0;
                    location.reload();
                    break;
                    
                case 'KICKED':
                    // Host kicked this player — clear session and go to login
                    localStorage.removeItem(LS_SESSION);
                    alert('You have been removed by the host.');
                    location.reload();
                    break;

                case 'SERVER_SHUTDOWN':
                    alert(data.message);
                    document.getElementById('status-dot').className = 'status-indicator status-yellow';
                    document.getElementById('status-text').textContent = 'Server restarting...';
                    break;
                    
                case 'ERROR':
                    console.error('Server error:', data.message);
                    break;
            }
        }

    function joinGame() {
    const name = document.getElementById('username-input').value.trim();
    const nameInput = document.getElementById('username-input');
    const gradeButtons = document.getElementById('grade-buttons');
    
    if (!name || !selectedGrade) {
        if (!name) {
            nameInput.classList.add('animate-shake');
            setTimeout(() => nameInput.classList.remove('animate-shake'), 600);
        }
        if (!selectedGrade) {
            gradeButtons.classList.add('animate-shake');
            setTimeout(() => gradeButtons.classList.remove('animate-shake'), 600);
        }
        return;
    }

    if (!ws || ws.readyState !== WebSocket.OPEN) {
        nameInput.style.borderColor = 'var(--error)';
        setTimeout(() => nameInput.style.borderColor = 'var(--sub)', 2000);
        document.getElementById('status-text').textContent = 'Nu ești conectat...';
        return;
    }
    
    // Reuse existing userId if same name, otherwise generate new one
    const existing = JSON.parse(localStorage.getItem(LS_SESSION) || 'null');
    const userId = (existing && existing.username === name)
        ? existing.userId
        : 'u_' + name.replace(/\s+/g, '_') + '_' + Date.now();

    const userData = { userId, username: name, grade: selectedGrade };
    localStorage.setItem(LS_SESSION, JSON.stringify(userData));
    document.getElementById('grade-display').textContent = selectedGrade;
    document.getElementById('display-name').textContent = name;
    
    hasJoined = true;
    ws.send(JSON.stringify({ 
        type: 'JOIN', 
        userId: userId, 
        username: name, 
        grade: selectedGrade, 
        role: 'player' 
    }));
}

        function changeName() {
            localStorage.removeItem(LS_SESSION);
            location.reload();
        }

        function runCountdown(num) {
            const el = document.getElementById('countdown-overlay');
            const txt = document.getElementById('countdown-number');
            el.style.display = 'flex';
            let c = num; 
            txt.textContent = c;
            const int = setInterval(() => {
                c--;
                if (c > 0) {
                    txt.textContent = c;
                } else { 
                    clearInterval(int); 
                    el.style.display = 'none'; 
                    focusInput(); 
                }
            }, 1000);
        }

        function startGame(text, duration, startTime) {
            gameState.active = true;
            gameState.duration = duration;
            gameState.startTime = startTime;
            
            gameState.words = text.split(' ');
            gameState.history = [];
            gameState.wordIndex = 0;
            gameState.inputVal = "";
            gameState.stats = {
                correctChars: 0,
                totalChars: 0,
                errors: 0,
                wpmSnapshots: []
            };

            els.wordsContainer.innerHTML = '';
            gameState.words.forEach(word => {
                const wDiv = document.createElement('div'); 
                wDiv.className = 'word';
                word.split('').forEach(char => {
                    const lSpan = document.createElement('span'); 
                    lSpan.className = 'letter'; 
                    lSpan.textContent = char;
                    wDiv.appendChild(lSpan);
                });
                els.wordsContainer.appendChild(wDiv);
            });

            els.scrollWrapper.style.transform = 'translateY(0px)';
            switchScreen('game-screen');
            
            setTimeout(() => {
                focusInput();
                updateUI();
            }, 100);
            
            if (gameState.timer) clearInterval(gameState.timer);
            gameState.timer = setInterval(gameLoop, 1000);
        }

        els.input.addEventListener('keydown', (e) => {
            if (!gameState.active) return;
            
            if (e.key === 'Backspace' && els.input.value.length === 0 && gameState.wordIndex > 0) {
                e.preventDefault();
                gameState.wordIndex--;
                const prev = gameState.history.pop();
                gameState.inputVal = prev; 
                els.input.value = prev;
                updateUI();
            }
        });

        els.input.addEventListener('input', (e) => {
            if (!gameState.active) return;
            
            const val = els.input.value;
            
            if (val.endsWith(' ')) {
                const typed = val.trim();
                gameState.history.push(typed);
                
                const target = gameState.words[gameState.wordIndex];
                const maxLen = Math.max(typed.length, target.length);
                
                for (let i = 0; i < maxLen; i++) {
                    gameState.stats.totalChars++;
                    if (typed[i] === target[i]) {
                        gameState.stats.correctChars++;
                    } else {
                        gameState.stats.errors++;
                    }
                }

                gameState.wordIndex++;
                gameState.inputVal = "";
                els.input.value = "";
            } else {
                gameState.inputVal = val;
            }
            
            updateUI();
            
            if (gameState.wordIndex >= gameState.words.length) {
                endGame();
            }
        });

        function updateUI() {
            const divs = els.wordsContainer.children;
            const idx = gameState.wordIndex;
            const input = gameState.inputVal;

            for (let i = 0; i < divs.length; i++) {
                const div = divs[i];
                const wStr = gameState.words[i];
                
                div.innerHTML = '';
                div.className = 'word';

                let comp = null;
                if (i < idx) { 
                    comp = gameState.history[i]; 
                } else if (i === idx) { 
                    comp = input; 
                    div.classList.add('active'); 
                } else {
                    comp = null;
                }

                if (comp !== null) {
                    const maxLen = Math.max(comp.length, wStr.length);
                    
                    for (let j = 0; j < maxLen; j++) {
                        const span = document.createElement('span');
                        span.className = 'letter';
                        
                        if (j < wStr.length) {
                            span.textContent = wStr[j];
                            
                            if (j < comp.length) {
                                if (comp[j] === wStr[j]) {
                                    span.classList.add('correct');
                                } else {
                                    span.classList.add('incorrect');
                                }
                            }
                        } else {
                            span.textContent = comp[j];
                            span.classList.add('extra');
                        }
                        
                        div.appendChild(span);
                    }
                    
                    if (comp.length > wStr.length) {
                        div.classList.add('error-underline');
                    }
                } else {
                    for (let j = 0; j < wStr.length; j++) {
                        const span = document.createElement('span');
                        span.className = 'letter';
                        span.textContent = wStr[j];
                        div.appendChild(span);
                    }
                }
            }

            updateCaretPosition();
            updateScroll();
        }

        function updateCaretPosition() {
            const curDiv = els.wordsContainer.children[gameState.wordIndex];
            if (!curDiv) return;

            const input = gameState.inputVal;
            let caretX, caretY;
            caretY = curDiv.offsetTop;

            if (input.length === 0) {
                caretX = curDiv.offsetLeft;
            } else {
                const spans = Array.from(curDiv.querySelectorAll('span.letter'));
                const targetIndex = input.length - 1;
                
                if (spans[targetIndex]) {
                    const targetSpan = spans[targetIndex];
                    const spanRect = targetSpan.getBoundingClientRect();
                    const containerRect = els.wordsContainer.getBoundingClientRect();
                    caretX = (spanRect.left - containerRect.left) + spanRect.width;
                } else {
                    caretX = curDiv.offsetLeft + curDiv.offsetWidth;
                }
            }

            els.caret.style.transform = `translate(${caretX}px, ${caretY + 5}px)`;
        }

        function updateScroll() {
            const curDiv = els.wordsContainer.children[gameState.wordIndex];
            if (!curDiv) return;

            const lineHeight = 40;
            const wordTop = curDiv.offsetTop;
            const currentLine = Math.floor(wordTop / lineHeight);
            
            let scrollAmount = 0;
            if (currentLine >= 2) {
                scrollAmount = (currentLine - 1) * lineHeight;
            }
            
            els.scrollWrapper.style.transform = `translateY(-${scrollAmount}px)`;
        }

        function gameLoop() {
            if (!gameState.active) return;
            
            const now = getServerTime();
            const elapsed = (now - gameState.startTime) / 1000;
            const remaining = Math.max(0, Math.round(gameState.duration - elapsed));
            document.getElementById('timer').textContent = remaining;

            if (elapsed > 0) {
                const mins = elapsed / 60;
                const wpm = Math.round((gameState.stats.correctChars / 5) / mins);
                document.getElementById('live-wpm').textContent = wpm;
                
                gameState.stats.wpmSnapshots.push(wpm);
                
                const totalTyped = gameState.stats.totalChars;
                const acc = totalTyped === 0 ? 100 : Math.round(((totalTyped - gameState.stats.errors) / totalTyped) * 100);
                document.getElementById('live-acc').textContent = Math.max(0, acc) + '%';

                const progress = Math.round((gameState.wordIndex / gameState.words.length) * 100);

                if (ws && ws.readyState === WebSocket.OPEN) {
                    // --- NEW: Calculate Consistency LIVE ---
                let liveCons = 0;
                const snaps = gameState.stats.wpmSnapshots;
                if (snaps.length >= 2) {
                    const mean = snaps.reduce((a, b) => a + b, 0) / snaps.length;
                    const squaredDiffs = snaps.map(val => Math.pow(val - mean, 2));
                    const variance = squaredDiffs.reduce((a, b) => a + b, 0) / snaps.length;
                    const stdDev = Math.sqrt(variance);
                    const cv = mean > 0 ? (stdDev / mean) : 0;
                    liveCons = Math.max(0, Math.min(100, Math.round((1 - cv) * 100)));
                }
                // ---------------------------------------

                if (ws && ws.readyState === WebSocket.OPEN) {
                    ws.send(JSON.stringify({ 
                        type: 'PROGRESS_UPDATE', 
                        wpm: wpm, 
                        acc: Math.max(0, acc), 
                        progress: progress,
                        // NEW: Send errors and consistency live
                        errors: gameState.stats.errors,
                        consistency: liveCons
                    }));
                }
                }
            }
            
            if (remaining <= 0) {
                endGame();
            }
        }

        function endGame() {
            if (!gameState.active) return;
            
            gameState.active = false;
            clearInterval(gameState.timer);
            
            // Issue #3: cancel any existing reload timer before starting a new one
            if (gameState.reloadTimer) {
                clearInterval(gameState.reloadTimer);
                gameState.reloadTimer = null;
            }

            const elapsed = (getServerTime() - gameState.startTime) / 1000;
            const mins = elapsed / 60;
            
            const wpm = Math.round((gameState.stats.correctChars / 5) / mins);
            const rawWpm = Math.round((gameState.stats.totalChars / 5) / mins);
            
            const totalTyped = gameState.stats.totalChars;
            const acc = totalTyped === 0 ? 0 : Math.round(((totalTyped - gameState.stats.errors) / totalTyped) * 100);
            
            let consistency = 0;
            const snapshots = gameState.stats.wpmSnapshots;
            if (snapshots.length >= 2) {
                const mean = snapshots.reduce((a, b) => a + b, 0) / snapshots.length;
                const squaredDiffs = snapshots.map(val => Math.pow(val - mean, 2));
                const variance = squaredDiffs.reduce((a, b) => a + b, 0) / snapshots.length;
                const stdDev = Math.sqrt(variance);
                const coefficientOfVariation = mean > 0 ? (stdDev / mean) : 0;
                consistency = Math.max(0, Math.min(100, Math.round((1 - coefficientOfVariation) * 100)));
            }

            document.getElementById('res-wpm').textContent = wpm;
            document.getElementById('res-acc').textContent = Math.max(0, acc) + '%';
            document.getElementById('res-raw').textContent = rawWpm;
            document.getElementById('res-cons').textContent = consistency + '%';
            updateRoundBadge();
            
            switchScreen('results-screen');
            
            if (ws && ws.readyState === WebSocket.OPEN) {
                ws.send(JSON.stringify({
                    type: 'FINISH',
                    wpm: wpm,
                    accuracy: Math.max(0, acc),
                    raw: rawWpm,
                    errors: gameState.stats.errors,
                    consistency: consistency
                }));
            }

            // Issue #8: Only start reload countdown if this is the last round.
            // For multi-round flows the server GAME_OVER handler moves to waiting-screen.
            let secondsLeft = 20; 
            const bar = document.getElementById('reload-bar');
            const secondsDisplay = document.getElementById('reload-seconds');
            
            gameState.reloadTimer = setInterval(() => {
                secondsLeft--;
                if (secondsDisplay) secondsDisplay.textContent = secondsLeft;
                if (bar) bar.style.width = ((secondsLeft / 20) * 100) + '%';
                
                if (secondsLeft <= 0) { 
                    clearInterval(gameState.reloadTimer);
                    gameState.reloadTimer = null;
                    location.reload(); 
                }
            }, 1000);
        }

        function focusInput() {
            if (gameState.active) {
                els.input.value = gameState.inputVal;
                els.input.focus();
                els.overlay.classList.remove('active');
                els.caret.classList.add('active');
                els.caret.classList.remove('animate');
                setTimeout(updateUI, 10);
            }
        }
        
        els.input.onblur = () => { 
            if (gameState.active) { 
                els.overlay.classList.add('active'); 
                els.caret.classList.remove('active');
                els.caret.classList.add('animate');
            }
        };

        // Periodic time sync
        setInterval(() => {
            if (ws && ws.readyState === WebSocket.OPEN) {
                const timeSinceSync = Date.now() - lastSyncTime;
                if (timeSinceSync > 30000) {
                    ws.send(JSON.stringify({ type: 'PING' }));
                }
            }
        }, 15000);

    
    </script>
</body>
</html>